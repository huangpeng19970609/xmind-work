> 注：
>
> 这边文章非常散落，更像是作为一本字典的查阅，而并不是一个需循渐进的文章结构。
>
> 不过流程的顺序是保留了。





## 讲述为什么需要reactFiber

1. 为什么要？
   - 一帧的渲染 - React 需要一种中断任务的目的
   - React建立了一套独特的`Fiber架构`,来处理任务中断与恢复、优先级调度
2. 什么是？
   - 每个Fiber节点对应一个React element ， Fiber节点构成的Fiber树就对应DOM树
   - 结构上
     1.  Fiber节点构成树的属性
     2. \2. React element对应的信息
        
        - Fiber节点可以保存对应的DOM节点 （树上有这个属性 startNode）
     3. \3. 作为动态的工作单元， 他保存着相关的信息
     4. \4. 调度优先级相关的信息
   - ##### 
3. 



## Reconciler

1. render阶段
2. 初始化与Fiber树构建
3. Diff算法
   - 比较新旧 Fiber 树，计算差异（如插入、更新、删除）
4.  调度与优先级
   - 与 Scheduler 协作，支持高优先级任务抢占低优先级任务
5. 标记副作用 effectTag
   - 为需要操作的节点打上标记（如 Placement、Update、Deletion）





## 认清一次任务



宏观上 一次任务的调度过

1. Schedule
2. render
3. commit





## Schedule

>  React细分每次任务调度为一帧(60HZ,16.6ms),为了给渲染线程流出时间更新,js有5ms的执行时间,如果超出那么会打断当前任务.这种方案被称为`时间分片`





## react的架构

1. 双缓冲策略
2. 调度任务流程  - 一次任务





## React.Render （render阶段）

> 构建Fiber



> 我总是建议您 应该仔细的敲这几个 方法命的字母来强调这种关联性的记忆



> 我们应该理解render 阶段到底做了什么事情即可。 



### 1. 开头方法 workLoopSync

 workLoopSync 是 【performSyncWorkOnRoot】 是一次任务的开启时候最开始的方法，所以你应该记住 【workLoopSync 】这个方法。

- 执行 workLoopSync 的时候，你需要记住

  这里总是以 while 循环执行， 判断 workInProress 与 shouldYield()

  - shouldYield的判断

    如果当前浏览器帧没有剩余时间，shouldYield会中止循环，直到浏览器有空闲时间后再继续遍历

  - workInProgress判断

- workLoopSync 的核心是进行了  【 performUnitOfWork】

  1. 请注意这个名称，中文的翻译可以是 【执行单元的任务】，请理解这个名称。

  2. performUnitOfWork的方法

     创建下一个`Fiber节点`， 并赋值给`workInProgress`

     并将`workInProgress`与已创建的`Fiber节点`连接起来构成`Fiber树`。

  3. performUnitOfWork
  
     就是构建 Fiber节点的过程，使用向下深度优先遍历遍历每一个。

> 总结 三个关键 
>
> 1. workLoopSync
> 2. while的判断：workInprogress & shouldYield （调度）
> 3. pefromUnitWork， 



### 2 beginWork（递）

首先从`rootFiber`开始向下深度优先遍历。为遍历到的每个`Fiber节点`调用[beginWork 方法](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)。

该方法会根据传入的`Fiber节点`创建`子Fiber节点`，并将这两个`Fiber节点`连接起来。

当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段

```ts
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {
}
```

#### 01 开始-update

若 current 不为空，则代表代表存在。尝试复用 （ ⭐ 此时为update逻辑  ）

即 【update】。 

````ts
 if (current !== null) {
    // ...省略

    // 复用current
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
 } 
````

复用的逻辑会读取

````js
const oldProps = current.memoizedProps;

const newProps = workInProgress.pendingProps;
````

如果可以满足  didReceiveUpdate === false的要求 （具体判断逻辑略）

⭐ 即可以直接复用前一次更新的`子Fiber`，不需要新建`子Fiber`



#### 01 开始-mount

current 不存在，则上一次的fiber节点是不存在的，则走入的是 mount对应的逻辑。

> 我们称呼其为mount是狭义于 当前的beginWork流程， 本质上其就是 current不存在的场景。

1. 根据tag不同，创建不同的Fiber节点

   ````jsx
    case IndeterminateComponent:
     // ...省略
     case LazyComponent:
     // ...省略
     case FunctionComponent:
     // ...省略
     case ClassComponent:
     // ...省略
     case HostRoot:
     // ...省略
     case HostComponent:
     // ...省略
     case HostText:
   ````

   对于我们常见的组件类型，如（`FunctionComponent`/`ClassComponent`/`HostComponent`），最终会进入[reconcileChildren](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L233)方法。



#### 02 reconcileChildren - 1

> 强调
>
> 不管是update还是mount 都会执行到这里
>
> 1. 这里出现了 创建新的Fiber节点
> 2. 这里出现了 Diff算法，diff算法在render阶段出现了！

1. 对于`mount`的组件，他会创建新的`子Fiber节点` 

   - mountChildFibers

     ```ts
      workInProgress.child = mountChildFibers(
           workInProgress,
           null,
           nextChildren,
           renderLanes
         );
     ```

2. 对于`update`的组件，他会将当前组件与该组件在上次更新时对应的`Fiber节点`比较（也就是俗称的`Diff`算法），将比较的结果生成新`Fiber节点`

   - reconcileChildFibers

     ⭐ `reconcileChildFibers`会为生成的`Fiber节点`带上`effectTag`属性，而`mountChildFibers`不会。

     ````ts
     workInProgress.child = reconcileChildFibers(
           workInProgress,
           current.child,
           nextChildren,
           renderLanes
         );
     ````

看到上面两个方法的workInProgress.child了吗？ 



`Fiber节点`并赋值给`workInProgress.child`，作为本次`beginWork`[返回值](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1158)，并作为下次`performUnitOfWork`执行时`workInProgress`的[传参](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1702)



#### 02 reconcileChildFibers (DIFF算法)

> 注意下 与 他的调用者方法名的区别是 在于 
>
> reconcileChildren
>
> reconcileChildFibers
>
> 子方法尾部多了 Fibers. 代表其返回的永远都是Fibers数据



> **`reconcileChildFibers` 是协调（Reconciliation）子节点的核心函数**，其核心职责是**比较当前 Fiber 节点的子节点（旧 Fiber 树）和新的子元素（由组件返回的 JSX）**，生成新的 Fiber 树（WorkInProgress Tree）



简略版本

```tsx
function reconcileChildFibers(
  returnFiber: Fiber,        // 父 Fiber 节点
  currentFirstChild: Fiber, // 旧 Fiber 树中的第一个子节点
  newChild: any             // 新的子元素（由组件返回的 JSX）
): Fiber | null {
      
  // 判断 newChild 的类型，选择不同的协调策略
  if (typeof newChild === 'string' || typeof newChild === 'number') {
    // 处理文本节点
    return placeSingleTextNode(returnFiber, currentFirstChild, newChild);
  }
      
      

  if (Array.isArray(newChild)) {
    // 处理数组或 Fragment
    return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
  }

  if (newChild === null || newChild === false) {
    // 删除所有子节点
    deleteRemainingChildren(returnFiber, currentFirstChild);
    return null;
  }

  if (isObject(newChild)) {
    // 处理单个 ReactElement（如 <div />）
    const newChildElement = newChild;
    if (newChildElement.$$typeof === REACT_ELEMENT_TYPE) {
      return placeSingleElement(returnFiber, currentFirstChild, newChildElement);
    }
  }

  // 默认处理其他情况
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```





> 将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中`n`是树中元素的数量.
>
> 如果在`React`中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂
>
> 故 
>
> 1. 只对同级元素进行`Diff`
> 2. 两个不同类型的元素会产生出不同的树， 如果元素由`div`变为`p`，React会销毁`div`及其子孙节点，并新建`p`及其子孙节点。
> 3. 开发者可以通过 `key prop`来暗示哪些子元素在不同的渲染下能保持稳定

1. 当`newChild`类型为`object`、`number`、`string`，代表同级只有一个节点
2. 当`newChild`类型为`Array`，同级有多个节点





#### 03 diff算法-单节点场景-reconcileSingleElement

**遍历旧的 Fiber 子节点链表**

1. 尝试复用 

   - 判断key是否相同 （   只对同级元素进行`Diff`  ）

   - 若相同，继续比较type是否相同 （ 两个不同类型的元素会产生出不同的树  ）

     故 若是不相同 ==> `deleteRemainingChildren`将`child`及其兄弟`fiber`都标记删除。

   - 若依旧相同， 只有都相同时一个`DOM节点`才能复用 

2. 新建Fiber

3. 例子

   ```js
   // 当前页面显示的
   ul > li * 3
   
   // 这次需要更新的
   ul > p
   ```

   现在有一个 ul 里面有 li3个元素，但是 要变为 ul下只有一个p元素。

   1. 那么， 由于本次更新时只有一个`p`，属于单一节点的`Diff`， 故触发的是 reconcileSingleElement
   2. reconcileSingleElement 遍历 currentFirstChild 当前， 遍历了对应的`DOM`为3个`li`。
   3. 发现当`key相同`且`type不同`时，代表已经命中了！但由于typ不同，所以都需要标记删除，没有必要寻找的意义了。
   4. 若是key不同，代表此li代表的Fiber不能够复用，继续寻找兄弟（Li）Fiber尝试复用。
   5. 注： 所以合理使用key真的是一个优化的手段。

4. 例子

   ```jsx
   // 习题1 更新前
   <div>ka song</div>
   // 更新后
   <p>ka song</p>
   
   // 习题2 更新前
   <div key="xxx">ka song</div>
   // 更新后
   <div key="ooo">ka song</div>
   
   // 习题3 更新前
   <div key="xxx">ka song</div>
   // 更新后
   <p key="ooo">ka song</p>
   
   // 习题4 更新前
   <div key="xxx">ka song</div>
   // 更新后
   <div key="xxx">xiao bei</div>
   ```

- 答案

  1. 未设置`key`,, 默认 `key = null;`, 更新前后key相同，都为`null`

     但 `type`改变则不能复用

  2. 不能复用

  3. 不能复用

  4.  更新前后`key`与`type`都未改变，可以复用。  然后继续循环判断g







#### 03 diff算法多节点

https://react.iamkasong.com/diff/multi.html#%E6%A6%82%E8%A7%88

这种情况下，`reconcileChildFibers`的`newChild`参数类型为`Array`

即 ⭐ newChild 为 Array

```tsx
function List () {
  return (
    <ul>
      <li key="0">0</li>
      <li key="1">1</li>
      <li key="2">2</li>
      <li key="3">3</li>
    </ul>
  )
}

# 对应的jsx对象
{
  $$typeof: Symbol(react.element),
  key: null,
  props: {
    children: [
      {$$typeof: Symbol(react.element), type: "li", key: "0", ref: null, props: {…}, …}
      {$$typeof: Symbol(react.element), type: "li", key: "1", ref: null, props: {…}, …}
      {$$typeof: Symbol(react.element), type: "li", key: "2", ref: null, props: {…}, …}
      {$$typeof: Symbol(react.element), type: "li", key: "3", ref: null, props: {…}, …}
    ]
  },
  ref: null,
  type: "ul"
}
```



> - 讨论场景
>
>   1. 节点更新
>   2. 节点新增或减少
>   3. 节点位置变化
>
> - 特别的优化 （ 确定更好的优先级别 ）
>
>   在日常开发中， 更新的频率是最高的。故不如先判断【更新】，然后考虑其他。
>
> - 特别的处理
>
>   操作数组总是希望 双指针提高效率，但是由于react的设计是。 current fiber 的，同级的`Fiber节点`是由`sibling`指针链接形成的单链表， 故我们不能使用。



#### 03-1 第一轮遍历

1. 遍历`newChildren`， 将`newChildren[i]`与`oldFiber`比较，判断`DOM节点`是否可复用

2. 如果可复用，`i++`，继续比较`newChildren[i]`与`oldFiber.sibling`

   注意 此时 oldFiber也会前进。可以复用则继续遍历

3. 当如果不可复用。

   - `key`不同， 立刻停止
   - `key`相同`type`不同， 标志 oldFiber为DELETE。 继续遍历

#### 03-2 第二轮遍历



1. 四类场景

   1. `newChildren`与`oldFiber`同时遍历完

      此时第二轮DIFF也不需要进行了

   2. newCildren没有结束，但是oldFilber结束了

      新的没有结束，旧的结束了。

      - 遍历剩下的`newChildren`为生成的`workInProgress fiber`依次标记`Placement`

      即新增！

   3. `newChildren`遍历完，`oldFiber`没遍历完

      所以需要遍历剩下的`oldFiber`，依次标记`Deletion`。

   4. `newChildren`与`oldFiber`都没遍历完

      大多数的场景下 此时 这个便是更新的规则，这也是最复杂的场景，也是最常见的场景了。

   

2. 更换数据的存储形态，修改为Map机制。

   我们将所有还未处理的`oldFiber`存入

   以`key`为key。`oldFiber`为value     的`Map`中

   ```javascript
   const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
   ```

   现在 existingChildren 便是 这样的一个OldFilber的Map。

   接下来遍历剩余的`newChildren`，通过`newChildren[i].key`就能在`existingChildren`中找到`key`相同的`oldFiber`



3. 具体步骤

   > 两个步骤
   >
   > 1. **构建 Key 到 Fiber 的映射表**
   > 2. **遍历新的子元素数组**

函数名称

| `mapRemainingChildren`   | 构建 key 到 Fiber 节点的映射表                               |
| ------------------------ | ------------------------------------------------------------ |
| `updateFromMap`          | 尝试从映射表中找到与当前新子元素具有相同 key 的旧 Fiber 节点 |
| `useFibe`                | 复用旧 Fiber，更新 props、index 等                           |
| `createFiberFromElement` | 创建新的 Fiber 节点                                          |
| `placeChild`             | 判断是否需要标记 Placement（移动位置）                       |
| `deleteChild`            | 标记节点为 `Deletion`，准备在 commit 阶段移除                |



1. 尝试从映射表中找到可以复用的 Fiber 节点

   type 与 tag

2. **如果找到了匹配项**

   我们使用 `useFiber` 函数复用旧 Fiber 节点，并更新其 `props` 和其他属性。

   - 如果旧节点的位置发生了变化（即其 `index` 小于 `lastPlacedIndex`），我们会为其添加 `Placement` 标记，表示需要移动该节点。
   - 否则，添加 `Update` 标记，表示只需要更新节点内容。
   - 最后，我们将复用的节点从映射表中删除。

3. **删除未使用的旧节点**



### 3 completeWork

`completeWork`也是针对不同`fiber.tag`调用不同的处理逻辑

此时也分为 两种情况 mount 与 update



#### 01 update (updateHostComponent)

> 当`update`时，`Fiber节点`已经存在对应`DOM节点`，所以不需要生成`DOM节点`。需要做的主要是处理`props`



1. 处理props

   - `onClick`、`onChange`等回调函数的注册
   - 处理`style prop`
   - 处理`DANGEROUSLY_SET_INNER_HTML prop`
   - 理`children prop`

2. 执行updateHostComponent

   ​	

   被处理完的`props`会被赋值给 workInProgress.updateQueue

   （等待后续的commit阶段执行）

   ```js
   workInProgress.updateQueue = (updatePayload: any);
   ```

#### 01 mount 

1. 为`Fiber节点`生成对应的`DOM节点`

   ```js
   // 为fiber创建对应DOM节点
   const instance = createInstance(
     type,
     newProps,
     rootContainerInstance,
     currentHostContext,
     workInProgress
   );
   ```

2. 将子孙`DOM节点`插入刚生成的`DOM节点`中

   ```js
   // 将子孙DOM节点插入刚生成的DOM节点中
   appendAllChildren(instance, workInProgress, false, false);
   // DOM节点赋值给fiber.stateNode
   workInProgress.stateNode = instance;
   ```

3. 与`update`逻辑中的`updateHostComponent`类似的处理`props`的过程

   ```js
   // 与update逻辑中的updateHostComponent类似的处理props的过程
   if (
     finalizeInitialChildren(
       instance,
       type,
       newProps,
       rootContainerInstance,
       currentHostContext
     )
   ) {
     markUpdate(workInProgress);
   }
   ```

## Commit阶段



### pre-commit阶段 （初始化）

1. 优先级相关的重置。
2. ref的绑定/解绑。

### before mutation 阶段 (调度useEffect)

遍历effectList并调用commitBeforeMutationEffects

1. 调用getSnapshotBeforeUpdate生命周期钩子

   - 类组件
     - 确保获取的是更新前的 DOM 状态
     - 必须与 componentDidUpdate 一起使用

2. 调度useEffect

   - 函数组件
   - 在 render 阶段，每个 useEffect 被推入当前 Fiber 的 updateQueue
   - 通过 queueEffectForPassivePhase 将 useEffect 回调提交到调度器。
   - 调度器根据优先级安排 useEffect 回调的执行时间

3. 处理DOM节点渲染/删除后的 autoFocus、blur逻辑

4. 疑问：为什么要调度？

   1. 避免堵塞

      **同步副作用**（如 `useLayoutEffect`）会在 DOM 更新后立即执行

      **异步副作用**（如 `useEffect`）被调度到浏览器空闲时执行，确保 DOM 更新和渲染优先完成，避免卡顿

      **异步执行副作用**：

      - 调度器（如 `requestIdleCallback`）在浏览器空闲时执行 `flushPassiveEffects`

   2. **确保副作用的执行顺序**

      先执行父组件的副作用，再执行子组件的副作用

5. 疑问：为什么要在这个阶段进行调度？

   **只有在 commit 阶段完成所有 DOM 更新后**，React 才能确定所有副作用的最终状态。

   - 如果在 layout 阶段后调度 `useEffec`

     会阻塞后续的浏览器任务。 

### mutation

1. 遍历effectList （commitMutationEffects）

   commitMutationEffects会遍历effectList，对每个Fiber节点执行如下三个操作

   - 根据ContentReset effectTag重置文字节点
   - 更新ref
   - 根据effectTag分别处理，其中effectTag包括(Placement | Update | Deletion | Hydrating)

2. 当Fiber节点含有Placement effectTag

   插入节点， 执行 commitPlacement。 

   > 如果你想插入一个节点，你也会按照如此的流程进行插入是最简单的。

   - 获取父级DOM节点
   - 获取Fiber节点的DOM兄弟节点
   - parentNode.insertBefore或parentNode.appendChild执行DOM插入操作

3. 当Fiber节点含有Update effectTag （Commit Work方法）

   - FunctionComponent mutation

     - 会遍历effectList，执行所有useLayoutEffect hook的销毁函数 （清理函数）

       1. 解释

           清理函数需要在新副作用执行前完成。 所以此刻需要处理 useLayoutEffect 

   - HostComponent mutation

     - 当fiber.tag为HostComponent

     - 最终会在updateDOMProperties中将render阶段 completeWork中为Fiber节点赋值的updateQueue对应的内容渲染在页面上。

       1. updateQueue

          - **Render 阶段：生成 `updateQueue`**

            **`completeWork`**时刻 会考虑调用 updateHostComponent， 生成updatePayload （一个数组，偶数索引是属性名，奇数索引是属性值）

          - **`updatePayload` 会被赋值给 `workInProgress.updateQueue`**，作为后续 DOM 更新的依据

       2. **应用 DOM 更新**

           `updatePayload` 应用到实际的 DOM 上。

           **`updateDOMProperties`** 。此方法会涉及

          - **`style`**：
          - `setInnerHTML` 
          - **`children`**：调用 `setTextContent` 设置文本内容。
          - **其他属性**：调用 `setValueForProperty` 设置属性值（如 `onClick`、`className` 等）。

4.  DELETE TAG

   - 意味着该Fiber节点对应的DOM节点需要从页面中删除。调用的方法为commitDeletion。
     - 递归调用Fiber节点及其子孙Fiber节点中，从页面移除Fiber节点对应DOM节点
       - 同时会处罚fiber.tag为ClassComponent的componentWillUnmount生命周期钩子
     - 解绑ref
     - 调度useEffect的销毁函数

### layout阶段

1. 遍历effectlists -> commitLayoutEffects

2. 调用生命周期钩子函数 与 hook

   - 对于函数组件， 调用`useLayoutEffect hook`的`回调函数`

     调度`useEffect`的`销毁`与`回调`函数

   - 对于class的组件

     根据 current来分别执行这两个生命周期

     [`componentDidMount`](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L538)或[`componentDidUpdate`](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L592)

3. ref的赋值

4. root.current = finishedWork;



## 状态更新



> 先了解我们之前的一些细节的内容的讲述。
>
> 1. render开始时的同步与异步
> 2. 触发更新后，一次流程是怎么样的
> 3. 认识Update对象
> 4. 调度更新

1. `render阶段`开始于`performSyncWorkOnRoot`或`performConcurrentWorkOnRoot`方法的调用。这取决于本次更新是同步更新还是异步更新

2. 一次触发更新的流程讲述

   1. 触发状态更新（根据场景调用不同方法）
   2. 创建Update对象
   3. render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）
   4. commit阶段（`commitRoot`）

3. 创建Update对象

   在`React`中，有如下方法可以触发状态更新（排除`SSR`相关）：

   - ReactDOM.render
   - this.setState
   - this.forceUpdate
   - useState
   - useReducer

   每次`状态更新`都会创建一个保存**更新状态相关内容**的对象，我们叫他`Update`。在`render阶段`的`beginWork`中会根据`Update`计算新的`state`

4. `render阶段`是从`rootFiber`开始向下遍历。那么如何从`触发状态更新的fiber`得到`rootFiber`呢

   > markUpdateLaneFromFiberToRoot

   从`触发状态更新的fiber`一直向上遍历到`rootFiber`，并返回`rootFiber`。

   由于不同更新优先级不尽相同，所以过程中还会更新遍历到的`fiber`的优先级

5. 调度更新

   现在我们拥有一个`rootFiber`，该`rootFiber`对应的`Fiber树`中某个`Fiber节点`包含一个`Update`。

   接下来通知`Scheduler`根据**更新**的优先级，决定以**同步**还是**异步**的方式调度本次更新。

   这里调用的方法是`ensureRootIsScheduled`。

   

   > 其中，`scheduleCallback`和`scheduleSyncCallback`会调用`Scheduler`提供的调度方法根据`优先级`调度回调函数执行

   ```tsx
   performSyncWorkOnRoot.bind(null, root);
   performConcurrentWorkOnRoot.bind(null, root);
   ```


### 01 Update的分类

ClassComponent`与`HostRoot`（`rootFiber.tag`对应类型）共用同一种`Update结构

- ReactDOM.render —— HostRoot
- this.setState —— ClassComponent
- this.forceUpdate —— ClassComponent
- useState —— FunctionComponent
- useReducer —— FunctionComponent

我们使用ClassComponent的update为结构

> 1. 优先级的对象
> 2. 回调函数
> 3. 载荷
> 4. next：链表

```js
const update: Update<*> = {
  eventTime,
  lane,
  suspenseConfig,
  tag: UpdateState,
  payload: null,
  callback: null,
  next: null,
};
```

1. lane优先级

2. tag 更新的类型： UpdateState` | `ReplaceState` | `ForceUpdate` | `CaptureUpdate

3. payload：更新挂载的数据

4. callback： 回调的执行函数。 

5. next： 链表结构

   `Fiber节点`上的多个`Update`会组成链表并被包含在`fiber.updateQueue`中。

### 02 updateQueue

- UpdateQueue的结构

  ```js
  const queue: UpdateQueue<State> = {
      baseState: fiber.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
      },
      effects: null,
    };
  ```

  1. baseState：本次更新前该`Fiber节点`的`state`

     - 如果引入git的思想，相当于当前的分支（master）

  2. firstBaseUpdate、lastBaseUpdate

     本次更新前该`Fiber节点`已保存的`Update`。 以链表形式存在，链表头为`firstBaseUpdate`，链表尾为`lastBaseUpdate`

     - 你可以认为他是一次commit的行为

  3. shared.pending

     触发更新时，产生的`Update`会保存在`shared.pending`中形成单向环状链表

     - 本次需要提交的`commit`

  4. effects

`Fiber节点`上的多个`Update`会组成链表并被包含在`fiber.updateQueue`中。

-  多个`Update`

  - 什么情况下一个Fiber节点会存在多个Update？

    这是非常的普遍的场景。

    ```js
    onClick() {
      this.setState({
        a: 1
      })
    
      this.setState({
        b: 2
      })
    }
    ```

- 最多两个updateQueue`

  1. currentFiberTree的updateQueue
  2. workInProgress fiber的updateQueue

### 03 updateQueue的例子

> 我们已一个产生了u3、u4的update的流程来解释这个updateQueue的。
>
> 关于具体如何去实现内部的机制，比如update如何创建，如何执行？render阶段如何更新jsx对象，这些事情将会在后续章节陈述, 现在我们只介绍Update这个流程内容。

1. baseUpdate

   假设一个场景，有一个fiber经历完commit阶段通过了渲染。

   但是有两个render阶段并没有处理的update（因为优先级低的原因），现在这两个update便是 baseUpdate。

   即 u1， u2。 

2. firstBaseUpdate、lastBaseUpdate 与 next

   ```js
   fiber.updateQueue.firstBaseUpdate === u1;
   fiber.updateQueue.lastBaseUpdate === u2;
   u1.next === u2;
   ```

3. 我们描述 updateQueen可以这么描述

   fiber.updateQueue: u1 ---> u2

4. 让我们继续假设，我们发生了状态更新，并且是两次。

   - 产生了两次update， 我们叫做为u3、u4

   - 创建了u3，便是要插入

     ```js
     fiber.updateQueue.shared.pending === u3;
     u3.next === u3;
     ```

   - 创建了u4

     ```js
     fiber.updateQueue.shared.pending === u4;
     u4.next === u3;
     u3.next === u4;
     ```

5. `shared.pending`的环状链表

   这是一个环形的链表。 此时便是如这个结构。他们头尾相连。

   ```js
   fiber.updateQueue.shared.pending:   u4 ──> u3
                                        ^      |                                    
                                        └──────┘
   ```

   现在这个结构为

   ```js
   fiber.updateQueue.baseUpdate: u1 --> u2 --> u3 --> u4
   ```

6. 遍历 `updateQueue.baseUpdate`链表

   - fiber.updateQueue.baseState`为`初始state
   - 依次与遍历到的每个`Update`计算并产生新的`state`
   - 若是优先级不高，就会跳跃。

7. 当遍历完成后获得的`state`，就是该`Fiber节点`在本次更新的`state`（源码中叫做`memoizedState`）。

8. `memoizedState`

   其在`render阶段`产生与上次更新不同的`JSX`对象，通过`Diff算法`产生`effectTag`，在`commit阶段`渲染在页面上

   

### 04 优先级的理解

1. 什么是`优先级`？依据是什么?

   > 因为状态更新的状态，是由用户产生，故用户对于交互执行的顺序必然有潜在预期。

   优先级：是状态更新的优先级。 对`交互`的预期顺序为`交互`产生的`状态更新`赋予不同优先级。 

   依据： 人机交互研究的结果，以此设定各类优先级。

   react的实践

   - 生命周期方法：同步执行。
   - 受控的用户输入：比如输入框内输入文字，同步执行。
   - 交互事件：比如动画，高优先级执行。
   - 其他：比如数据请求，低优先级执行

2. 如何调度优先级？

   `React`通过`Scheduler`调度任务。 但是具体如何呢？

   - Scheduler 提供了 【runWithPriority】方法。

     该方法接收一个`优先级`常量与一个`回调函数`作为参数。`回调函数`会以`优先级`高低为顺序排列在一个`定时器`中并在合适的时间触发

### 04 优先级的例子

1. 当前的baseState为 黑夜模式的字母 “H”

   即 currentFiber上有这个。

   ```js
   fiber.updateQueue = {
     baseState: {
       blackTheme: true,
       text: 'H'
     },
     firstBaseUpdate: null,
     lastBaseUpdate: null
     shared: {
       pending: "【Update-关闭黑夜模式】"
     },
     effects: null
   };
   ```

2. 我 点击了 “关闭黑夜模式”的按钮。

3. 创建Update，为”关闭黑夜模式“， 此Update优先级不高。

   - workInProgress Fiber
   - Reac t进入Render阶段

4. 我继续输入， 输入 “1”。

   中断`u1`产生的`render阶段`。 故 现在会变成这样子

   ```js
   fiber.updateQueue.shared.pending === “”1 ----> 【Update-关闭黑夜模式】
                                        ^        |
                                        |________|
   ```

5. 此时，“关闭黑夜模式”的Update的render阶段还没有结束，但输入“1”的行为优先级高

   - React终止前一个render任务。
   - 创建新的Update “输入1”

   > u2`产生的`render阶段
   >
   > 1. 遍历 baseUpdate
   > 2. 处理优先级合适的`Update`
   > 3. 跳过u1， 执行 u2
   > 4. 最终`u2`完成`render - commit阶段`

   ```js
   fiber.updateQueue = {
     baseState: {
       blackTheme: true,
       text: 'HI'
     },
     firstBaseUpdate: u1,
     lastBaseUpdate: u2
     shared: {
       pending: null
     },
     effects: null
   };
   ```

6. “输入1”的commit提交，页面渲染。

7. React在输入“1”的Commit成功后，基于最近的状态重新开始之前的中断的“关闭黑夜模式”

8. “关闭黑夜模式”Commit

   

### 05 保证状态正确

- render阶段既然是可以被中断的，那么updateQueue中Update如何不丢失?
- 如果 状态之间存在依赖，跳过状态同时，又怎么保证正确的执行下一个状态?



1. 如何保证`Update`不丢失

   - shared.pending

     他会被同时连接到 workInProgress 与 current的 UpdateQueue的lastBaseUpdate上。这样做的目的是为了克隆。

   - `render阶段`被中断后重新开始时

     当前的current会克隆 workInprogress的updateQueue。

     lastBaseUpdate 保存了 上一次的 Update，故根本不会丢失Update。

      即 保证了状态的一定是正确的！

   - commit阶段也是同理

2. 保证状态依赖的连续性

   即当有`Update`被跳过时，`下次更新的baseState !== 上次更新的memoizedState`

   - **`baseState`**：表示初始状态，是所有未处理的 `update` 的起点。

   - **`memoizedState`**：表示当前已应用所有已处理的 `update` 后的状态。

     确保每次更新基于最新的 `memoizedState`。

   `baseState` 保留未处理的 `update` 起点

   `memoizedState` 反映已处理的状态

   ```js
   baseState: ''
   # 数字代表优先级 1 优先级最高
   shared.pending: A1 --> B2 --> C1 --> D2 
   ```

   第一次, render

   ```js
   baseState: "";
   baseUpdate: null;
   render阶段使用的Update: [A1, C1];
   memoizedState: "AC";
   ```

   第二次 render

   ```js
   baseState: "A";
   baseUpdate: B2-- > C1-- > D2;
   render阶段使用的Update: [B2, C1, D2];
   memoizedState: "ABCD";
   ```



### 06 ReactDOM.render

1. 创建fiber

   - ReactDom.render 创建 fiberRootNode （应用根节点） 与 rootFiber （组件根节点）

   - 这一过程 在 createFiberRoot

     完成`fiberRootNode`和`rootFiber`的创建以及关联。并初始化`updateQueue`

   - fiberRootNode.stateNode  = rootFiber

     ```js
     export function createFiberRoot(
       containerInfo: any,
       tag: RootTag,
       hydrate: boolean,
       hydrationCallbacks: null | SuspenseHydrationCallbacks,
     ): FiberRoot {
       // 创建fiberRootNode
       const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);
       
       // 创建rootFiber
       const uninitializedFiber = createHostRootFiber(tag);
     
       // 连接rootFiber与fiberRootNode
       root.current = uninitializedFiber;
       uninitializedFiber.stateNode = root;
     
       // 初始化updateQueue
       initializeUpdateQueue(uninitializedFiber);
     
       return root;
     }
     ```

2. 创建update

   updateContainer

   创建`Update`来开启一次更新

   ```js
   export function updateContainer(
     element: ReactNodeList,
     container: OpaqueRoot,
     parentComponent: ?React$Component<any, any>,
     callback: ?Function,
   ): Lane {
     // ...省略与逻辑不相关代码
   
     // 创建update
     const update = createUpdate(eventTime, lane, suspenseConfig);
     
     // update.payload为需要挂载在根节点的组件
     update.payload = {element};
   
     // callback为ReactDOM.render的第三个参数 —— 回调函数
     callback = callback === undefined ? null : callback;
     if (callback !== null) {
       update.callback = callback;
     }
   
     // 将生成的update加入updateQueue
     enqueueUpdate(current, update);
     // 调度更新
     scheduleUpdateOnFiber(current, lane, eventTime);
   
     // ...省略与逻辑不相关代码
   }
   ```

### 07 setState

1. ​	this.setState`内会调用`this.updater.enqueueSetState

   ```js
   Component.prototype.setState = function (partialState, callback) {
     this.updater.enqueueSetState(this, partialState, callback, 'setState');
   };
   ```

2. enqueueSetState

   `enqueueSetState`方法中就是我们熟悉的从`创建update`到`调度update`的流程

   ```js
   enqueueSetState(inst, payload, callback) {
     // 通过组件实例获取对应fiber
     const fiber = getInstance(inst);
   
     const eventTime = requestEventTime();
     const suspenseConfig = requestCurrentSuspenseConfig();
   
     // 获取优先级
     const lane = requestUpdateLane(fiber, suspenseConfig);
   
     // 创建update
     const update = createUpdate(eventTime, lane, suspenseConfig);
   
     update.payload = payload;
   
     // 赋值回调函数
     if (callback !== undefined && callback !== null) {
       update.callback = callback;
     }
   
     // 将update插入updateQueue
     enqueueUpdate(fiber, update);
     // 调度update
     scheduleUpdateOnFiber(fiber, lane, eventTime);
   }
   ```

3. forceUpdate

   除了赋值`update.tag = ForceUpdate;`以及没有`payload`外，其他逻辑与`this.setState`一致。

   ```js
   enqueueForceUpdate(inst, callback) {
       const fiber = getInstance(inst);
       const eventTime = requestEventTime();
       const suspenseConfig = requestCurrentSuspenseConfig();
       const lane = requestUpdateLane(fiber, suspenseConfig);
   
       const update = createUpdate(eventTime, lane, suspenseConfig);
   
       // 赋值tag为ForceUpdate
       update.tag = ForceUpdate;
   
       if (callback !== undefined && callback !== null) {
         update.callback = callback;
       }
   
       enqueueUpdate(fiber, update);
       scheduleUpdateOnFiber(fiber, lane, eventTime);
     },
   };
   ```

4. 





## ReactDom.render 流程概述

1. 创建fiberRootNode、rootFiber、updateQueue（`legacyCreateRootFromDOMContainer`）

2. 创建Update对象（`updateContainer`）

3. 从fiber到root（`markUpdateLaneFromFiberToRoot`）

4. 调度更新（`ensureRootIsScheduled`）

5. render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）

6. commit阶段（`commitRoot`）





## Hook

### 01 react与hooks

> React Conf 2018:
>
> ​	你可以从`React`的`LOGO`中看到这些围绕着`核心`的`电子飞行轨道`，`Hooks`可能一直就在其中

1. React的图标代表的是原子，理念是不可分割的。

   - react中拆分单元，每一个单元都是Component。
   - Hooks更像是 组成原子的电子

2. React的世界概念是

   ````jsx
   Schedule => render => commit 
   ````

   这个流程是`React`世界最底层的`运行规律`

3. 生命周期 与 Hooks

   - 生命周期像是 React描述世界的手段
   - Hooks 更像是 React 内部运行的各种概念。

   比如

   Hooks更像是电子的概念，用来解释原子。

   - componentWillReceiveProps `render阶段`执行
   - useEffect 是在 `commit阶段`完成渲染后异步执行

### 02 useState例子

这是一个hook的例子

```js
function App() {
  const [num, updateNum] = useState(0);

  return <p onClick={() => updateNum((num) => num + 1)}>{num}</p>;
}
```

我们可以抽象概念为

1. 第一步：通过一些途径产生`更新`，`更新`会造成组件`render`

   此处， 更新可以分为 mount 与 update

   - mount ： ReactDom.render 产生 mount的更新 
   - update:  即 num + 1

2. 第二步：组件`render`时， `useState`返回的`num`为更新后的结果



### 02  ⭐ update 、 hook 、 queue与 fiber

1. Hook 

   是函数组件中每个 `useXXX` 调用（如 `useState`、`useEffect` 等）生成的实体，用于保存该 Hook 的状态、队列和链表关系

   ```js
   hook = {
       
     // 保存该 Hook 的更新队列（用于存储更新动作）
     queue: {
       pending: null, // 指向 Update 链表的起始位置
     },
       
     // 保存该 Hook 的最新状态值（如 useState 的 count）
     memoizedState: initialState,
       
     // 指向下一个 Hook，形成单向无环链表
     next: null,
       
   };
   ```

   - next： 

     此链表是**单向无环**

   - queue：

     调用 `setCount` 产生的 `update`， 类似于fiber的.queue.

     通过 `dispatch` 生成的 `update` 都会加入此链表

   - `memoizedState` 

     保存当前 Hook 的状态值 ( initialState  )

2. Fiber

   每一个fiber都有这样的属性，用于管理组件级别的更新逻辑

   - **`updateQueue`** 

     如类组件的 `setState` 或函数组件的副作用

     1. 如果组件有副作用（如 `useEffect`），这些副作用会被添加到 Fiber 的 `updateQueue` 中
     2. 类组件的 `setState` 更新

   -  **Fiber 的 `memoizedState`**

     用于存储该组件的 Hook 链表（即所有 Hook 的起点）

3. 我们再次重新描述这个过程

   1. 调用 setCount => 触发 dispatch方法

   2. dispatch方法

      - 创建update
      - 将update 添加进对应的hook.queue

   3. 调度更新

      **scheduleUpdateOnFiber**

      ```js
      scheduleUpdateOnFiber(fiber, lane, eventTime);
      ```

   4. **render-Reconciliation**

      - React 会遍历 Fiber 树，重新计算每个组件的状态（包括 Hook 的 `memoizedState`）
      - 若queue.pending有更新， 合并update，计算新的`memoizedState`


### 03 第一步： 更新（update）

通过一些途径产生`更新`，`更新`会造成组件`render`

> 1. 创建update
> 2. updatequeue执行
> 3. schedule()

1. 调用`updateNum`实际调用的是`dispatchAction.bind(null, hook.queue)`

   ```react
   function dispatchAction(queue, action) {
       
     // 创建update的结构
     const update = {
       action,
       next: null,
     };
   
     // 环状单向链表操作
     if (queue.pending === null) {
       update.next = update;
     } else {
       update.next = queue.pending.next;
       queue.pending.next = update;
     }
     queue.pending = update;
   
     // 模拟React开始调度更新
     schedule();
   }
   ```

   不同于`ClassComponent`的实例可以存储数据，对于`FunctionComponent`，`queue`存储在哪里呢？

   答案是：`FunctionComponent`对应的`fiber`中。

   ```js
   // App组件对应的fiber对象
   const fiber = {
     // 保存该FunctionComponent对应的Hooks链表
     memoizedState: null,
     // 指向App函数
     stateNode: App,
   };
   ```

2. hook的结构

   ```js
   hook = {
     // 保存update的queue，即上文介绍的queue
     queue: {
       pending: null,
     },
     // 保存hook对应的state
     memoizedState: initialState,
     // 与下一个Hook连接形成单向无环链表
     next: null,
   };
   ```

   > 产生的`update`保存在`useState`对应的`hook.queue`中

3.  模拟调度流程

   ```js
   // 首次render时是mount
   isMount = true;
   
   function schedule() {
     // 更新前将workInProgressHook重置为fiber保存的第一个Hook
     workInProgressHook = fiber.memoizedState;
       
     // 触发组件render
     fiber.stateNode();
       
     // 组件首次render为mount，以后再触发的更新为update
     isMount = false;
   }
   ```

   

### 04 useState的简易实现

组件`render`时`useState`返回的`num`为更新后的结果。

```js
function useState(initialState) {
    
  // 当前useState使用的hook会被赋值该该变量
  let hook;

  // ...mount时需要生成hook对象
  if (isMount) {
    
  } 
  // ...update时从workInProgressHook中取出该useState对应的hook
  else {
   
  }

  let baseState = hook.memoizedState;
    
    
   // ...根据queue.pending中保存的update更新state
  if (hook.queue.pending) {
   
  }
    
  hook.memoizedState = baseState;

  return [baseState, dispatchAction.bind(null, hook.queue)];
}
```

1. 生成hook对象

   ```js
   if (isMount) {
     // mount时为该useState生成hook
     hook = {
       queue: {
         pending: null,
       },
       memoizedState: initialState,
       next: null,
     };
   
     // 将hook插入fiber.memoizedState链表末尾
     if (!fiber.memoizedState) {
       fiber.memoizedState = hook;
     } else {
       workInProgressHook.next = hook;
     }
     // 移动workInProgressHook指针
     workInProgressHook = hook;
   } else {
     // update时找到对应hook
     hook = workInProgressHook;
     // 移动workInProgressHook指针
     workInProgressHook = workInProgressHook.next;
   }
   ```

2. 则更新其`state`

   ```js
   // update执行前的初始state
   let baseState = hook.memoizedState;
   
   if (hook.queue.pending) {
     // 获取update环状单向链表中第一个update
     let firstUpdate = hook.queue.pending.next;
   
     do {
       // 执行update action
       const action = firstUpdate.action;
       baseState = action(baseState);
       firstUpdate = firstUpdate.next;
   
       // 最后一个update执行完后跳出循环
     } while (firstUpdate !== hook.queue.pending.next);
   
     // 清空queue.pending
     hook.queue.pending = null;
   }
   
   // 将update action执行完后的state作为memoizedState
   hook.memoizedState = baseState;
   ```

### 05 认识dispatcher



在真实的`Hooks`中，组件`mount`时的`hook`与`update`时的`hook`来源于不同的对象

```js
ReactCurrentDispatcher.current =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;  
```

具体结构为

```js
// mount时的Dispatcher
const HooksDispatcherOnMount: Dispatcher = {
  useCallback: mountCallback,
  useContext: readContext,
  useEffect: mountEffect,
  useImperativeHandle: mountImperativeHandle,
  useLayoutEffect: mountLayoutEffect,
  useMemo: mountMemo,
  useReducer: mountReducer,
  useRef: mountRef,
  useState: mountState,
  // ...省略
};

// update时的Dispatcher
const HooksDispatcherOnUpdate: Dispatcher = {
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: updateState,
  // ...省略
};
```

当错误的书写了嵌套形式的`hook`

此时调用的是 ContextOnlyDispatcher， 直接抛出异常。

```js
export const ContextOnlyDispatcher: Dispatcher = {
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  // ...省略
```

### 06 Hook的数据结构

hook类似于 fiber的updateQueue

```js
const hook: Hook = {
    
  # 当前渲染使用的状态值
  memoizedState: null,

  # 时间分片（Concurrent Mode）中用于保存基础状态，在多次更新中作为基准
  baseState: null,
    
  # Update[] 保存那些尚未应用到 baseState 的更新（用于恢复未完成的更新）
  baseQueue: null,
    
  # Update[] 当前的更新队列，例如由 setState 触发的多个更新
  queue: null,

  # 指向下一个 Hook，形成单向链表
  next: null,
};
```

不同类型`hook`的`memoizedState`保存不同类型数据

1. useState

   `memoizedState`存储state

2. useReducer

   存储state

3. useEffect

   一个effct数据结构

   - 回调函数
   - 依赖项

   并且effect链表也会被存储到 fiber.updateQueue

4. useRef

   存储的是对象： {current: 1}

5. useMemo

   存储的是 useMemo(callback, [depA])`，`memoizedState`保存`[callback(), depA]

6. useCallback：

7. 对于useCallback(callback, [depA])

   `useCallback`保存的是`callback`函数本身，而`useMemo`保存的是`callback`函数的执行结果

8. useContext

   不存储

### 07 useState 与 useReducer

> `Redux`的作者`Dan`加入`React`核心团队后的一大贡献就是“将`Redux`的理念带入`React`”



我们将其分为两个阶段

1. `声明阶段`即`App`调用时，会依次执行`useReducer`与`useState`方法。
2. `调用阶段`即点击按钮后，`dispatch`或`updateNum`被调用时

```js
function App() {
  const [state, dispatch] = useReducer(reducer, { a: 1 });

  const [num, updateNum] = useState(0);

  return (
    <div>
      <button onClick={() => dispatch({ type: "a" })}>{state.a}</button>
      <button onClick={() => updateNum((num) => num + 1)}>{num}</button>
    </div>
  );
}
```

### 08 useState的声明阶段

dispatcher 会调用不同的函数来执行。

```js
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState)
}

function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
```

mount时，

1. useReducer 调用的是 mountReducer

   ```js
   function mountState<S>(
     initialState: (() => S) | S
   ): [S, Dispatch<BasicStateAction<S>>] {
       
     // 1. 创建并返回当前的hook
     const hook = mountWorkInProgressHook();
   
     // ...赋值初始state
   
     // 2. 创建queue
     const queue = (hook.queue = {
       pending: null,
       dispatch: null,
       lastRenderedReducer: basicStateReducer,
       lastRenderedState: (initialState: any),
     });
   
     // 3. 创建dispatch
     return [hook.memoizedState, dispatch];
   }
   ```

2. useState 会调用 mountState。

   ```js
   function mountReducer<S, I, A>(
     reducer: (S, A) => S,
     initialArg: I,
     init?: (I) => S
   ): [S, Dispatch<A>] {
     // 创建并返回当前的hook
     const hook = mountWorkInProgressHook();
   
     // ...赋值初始state
   
     // 创建queue
     const queue = (hook.queue = {
       pending: null,
       dispatch: null,
       lastRenderedReducer: reducer,
       lastRenderedState: (initialState: any),
     });
   
     // ...创建dispatch
     return [hook.memoizedState, dispatch];
   }
   ```

他们基一致，这两个`Hook`的唯一区别为`queue`参数的`lastRenderedReducer`字段

```js
const queue = (hook.queue = {
    
  // 与极简实现中的同名字段意义相同，保存update对象
  pending: null,
    
  // 保存dispatchAction.bind()的值
  dispatch: null,
    
  // 上一次render时使用的reducer
  lastRenderedReducer: reducer,
    
  // 上一次render时的state
  lastRenderedState: (initialState: any),
});
```

useReducer  使用的是 basicStateReducer

useState  使用的是 reducer。

1. update时

   ```js
   function updateReducer<S, I, A>(
     reducer: (S, A) => S,
     initialArg: I,
     init?: (I) => S
   ): [S, Dispatch<A>] {
     // 获取当前hook
     const hook = updateWorkInProgressHook();
     const queue = hook.queue;
   
     queue.lastRenderedReducer = reducer;
   
     // ...同update与updateQueue类似的更新逻辑
   
     const dispatch: Dispatch<A> = (queue.dispatch: any);
     return [hook.memoizedState, dispatch];
   }
   ```

   找到对应的`hook`，根据`update`计算该`hook`的新`state`并返回

其中

### 09 useState调用阶段

```js
function dispatchAction(fiber, queue, action) {
  // ...创建update
  var update = {
    eventTime: eventTime,
    lane: lane,
    suspenseConfig: suspenseConfig,
    action: action,
    eagerReducer: null,
    eagerState: null,
    next: null,
  };

  // ...将update加入queue.pending

  var alternate = fiber.alternate;

  if (
    fiber === currentlyRenderingFiber$1 ||
    (alternate !== null && alternate === currentlyRenderingFiber$1)
  ) {
    // render阶段触发的更新
    didScheduleRenderPhaseUpdateDuringThisPass =
      didScheduleRenderPhaseUpdate = true;
  } else {
    if (
      fiber.lanes === NoLanes &&
      (alternate === null || alternate.lanes === NoLanes)
    ) {
      // ...fiber的updateQueue为空，优化路径
    }

    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
}
```

创建`update`，将`update`加入`queue.pending`中，并开启调度。

### 10  useEffect

> commit时刻，在`flushPassiveEffects`方法内部会从全局变量`rootWithPendingPassiveEffects`获取`effectList`

1. flushPassiveEffectsImpl

   - 销毁函数的执行

     必须遵循组件的全部销毁，才能全部执行。

     ```js
     // pendingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect
     const unmountEffects = pendingPassiveHookEffectsUnmount;
       pendingPassiveHookEffectsUnmount = [];
       for (let i = 0; i < unmountEffects.length; i += 2) {
         const effect = ((unmountEffects[i]: any): HookEffect);
         const fiber = ((unmountEffects[i + 1]: any): Fiber);
         const destroy = effect.destroy;
         effect.destroy = undefined;
     
         if (typeof destroy === 'function') {
           // 销毁函数存在则执行
           try {
             destroy();
           } catch (error) {
             captureCommitPhaseError(fiber, error);
           }
         }
       }
     ```

2. 回调函数的执行

   ```js
   const mountEffects = pendingPassiveHookEffectsMount;
   pendingPassiveHookEffectsMount = [];
   for (let i = 0; i < mountEffects.length; i += 2) {
     const effect = ((mountEffects[i]: any): HookEffect);
     const fiber = ((mountEffects[i + 1]: any): Fiber);
     
     try {
       const create = effect.create;
      effect.destroy = create();
     } catch (error) {
       captureCommitPhaseError(fiber, error);
     }
   }
   ```

### 11 useRef

### 12 useMemo 与 useCallback



## Concurrent模式

自始至终，React团队都是为了实现 Concurrent 而努力了两年的时间。

ConCurrent的理念便是， 实现异步可中断的更新。

1. 为此 Fiber架构的意义便是在于

   -  单个组件作为工作单元，实现以【组件】为粒度的异步可中断的更新。

2. Scheduler

   调度器来进行调度任务。

3. lane模型

   - 更新对应的优先级？
   - 如何打断？

> Suspense
>
> useDeferredValue
>
> batchedUpdates
>
> 等这些APi 都可以根据 Concurrent来进行了一次迭代升级。

### 01 时间切片

时间切片在做什么？ 

- 时间切片在模拟浏览器的 requestIdleCallback 的行为。

- 下图是浏览器一帧中可以用于执行`JS`的时机( 除去【浏览器重排/重绘  】)

  ```js
  一个task(宏任务) 
      -- 队列中全部job(微任务) 
          -- requestAnimationFrame 
              -- 浏览器重排/重绘 
                  -- requestIdleCallback  
  ```

> requestAnimationFrame 总是在 浏览器重排/重绘前执行 JS，所以我们都是在这里实现动画。
>
> `requestIdleCallback`是在“浏览器重排/重绘”后如果当前帧还有空余时间时被调用的
>
> 1. 故如果我们希望能够实现时间切片的功能，那么就只能通过【宏任务】之前来执行。
>
>    其中有setTimeout 与 [MessageChannel](https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel)
>
> 2. MessageChannel比setTimeout还要更加靠前。
>
>    故实现Scheduler的时候，总是考虑先使用 MessageChannel回调函数，若宿主环境不支持，就使用setTimeout

### 02 unstable_runWithPriority

在`React`内部凡是涉及到`优先级`调度的地方，都会使用`unstable_runWithPriority`。

> Schedule下对外包暴露方法 unstable_runWithPriority。
>
> 该方法用于以某个`优先级`注册回调函数。

```jsx
function unstable_runWithPriority(priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
    case LowPriority:
    case IdlePriority:
      break;
    default:
      priorityLevel = NormalPriority;
  }

  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}
```

1. render阶段时，每次遍历都会判断shouldYield方法。

   - 目的便是为了中断。
   - 是否中断的依据，最重要的一点便是每个任务的剩余时间是否用完。

   ```js
   function workLoopConcurrent() {
     // Perform work until Scheduler asks us to yield
     while (workInProgress !== null && !shouldYield()) {
       performUnitOfWork(workInProgress);
     }
   }
   ```

2. commit阶段

   `beforeMutation`阶段会调度`useEffect`的回调

   ```js
   if (!rootDoesHavePassiveEffects) {
     rootDoesHavePassiveEffects = true;
     scheduleCallback(NormalSchedulerPriority, () => {
       flushPassiveEffects();
       return null;
     });
   }
   ```

3. 不同的优先级代表的是 不同的过期时间。

4. 不同优先级任务的排序

   - 已就绪任务 taskQueue
   - 未就绪任务 timerQueue

### 03 lane模型

> 不同的赛车疾驰在不同的赛道。内圈的赛道总长度更短，外圈更长。某几个临近的赛道的长度可以看作差不多长。
>
> `lane`模型借鉴了同样的概念，使用31位的二进制表示31条赛道，位数越小的赛道`优先级`越高，某些相邻的赛道拥有相同`优先级`。

```js
export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;

export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
export const SyncBatchedLane: Lane = /*                 */ 0b0000000000000000000000000000010;
```

1. 同步优先级占用的赛道为第一位

2. 其中 也会有人可以占据多条赛道

   这就是`批`的概念，被称作`lanes`

   ```js
   const InputDiscreteLanes: Lanes = /*                    */ 0b0000000000000000000000000011000;
   export const DefaultLanes: Lanes = /*                   */ 0b0000000000000000000111000000000;
   const TransitionLanes: Lanes = /*                       */ 0b0000000001111111110000000000000;
   ```

   其中`InputDiscreteLanes`是“用户交互”触发更新会拥有的`优先级`范围。

   `DefaultLanes`是“请求数据返回后触发更新”拥有的`优先级`范围。

   `TransitionLanes`是`Suspense`、`useTransition`、`useDeferredValue`拥有的`优先级`范围。

3. 